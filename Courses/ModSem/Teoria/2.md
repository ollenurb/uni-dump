\newpage

# RDF

* RDF è il formato tramite il quale vengono condivisi i dati nei linked data
* Centrale a RDF è il concetto di *risorsa* che può essere un servizio,
  documento, risorsa, ecc (in generale, qualsiasi cosa identificabile per mezzo
  di un IRI)
* Essenziale è la differenza tra RDF e RDFS:
    * RDF permette di descrivere **risorse**
    * RDFS permette di descriverre **relazioni tra risorse**
* Le specifiche di RDF sono date da una famiglia di diversi documenti. Quello
  più importante è l'RDF primer 1.0
* Come detto, RDF nasce per descrivere risorse digitali identificabili
* Il suo data model è basato sul concetto di **grafo** in cui:
    * I *nodi* rappresentano entità
    * Gli *archi* relazioni tra esse

> L'unità di base di RDF è una **tripla**, composta da soggetto, predicato e
> oggetto. Il soggetto e oggetto possono essere **IRI** o **blank nodes**,
> l'oggetto può essere anche un **letterale**, il predicato può essere solo un
> **IRI**.

* **Importante**: Un insieme di **Triple RDF** forma un **Grafo RDF**
* es. `<the Mona Lisa><was created><Leonardo da Vinci>`
    * **Soggetto**: Mona Lisa;
    * **Predicato**: è stata creata;
    * **Oggetto**: Leonardo da Vinci.
* Un grafo viene poi rappresentato da un identificativo IRI oppure da un blank
  node, per questa ragione anche i grafi possono essere a loro volta dei nodi di
  un grafo.
* A loro volta, i grafi possono essere raggruppati tra loro per formare un *data
  set RDF*. Esso è composto da:
    * Un grafo anonimo (*default graph*)
    * Zero o più grafi con un nome (*named graphs*)
* Tutti gli elementi di una tripla devono essere riconducibili a entità
  presenti nel web.
    * Lo strumento per poterle rappresentare è dato dal sistema degli IRI;
    * Come detto, il predicato è sempre rappresentato da un IRI.
* I blank node sono dei nodi che fungono da **variabile**
    * Permettono di denotare delle risorse senza dover ricorrere agli IRI
    * es. `<><is a><Tree>`
    * Possono essere associati a identificativi all'interno della
      rappresentazione delle triple in un determinato store, ma non hanno
      significato al di fuori di esso (essenzialmente vengono *istanziate* da
      specifiche istanze all'interno di specifici store)
* Il punto di RDF è quello di riutilizzare vocabolari standard per che
  rappresentano i termini, invece che ri-definirli sempre da 0
    * I vari vocabolari vengono spesso identificati da prefissi che ne indicano
      il namespace (es. `foaf`)

## Serializzazioni
* RDF di per sè è una *sintassi astratta* che deve poi essere serializzata in
  un formato specifico. Nel tempo sono stati proposti diversi formati di
  serializzazione, ognuno con i suoi pro e contro:
    * Turle (preferito per coincisione e leggibilità)
    * RDF/XML
    * N-triples
    * Json LD
    * N3
    * RDFa
* Il formato Turtle permette di definire dei prefissi in modo da definire i vari
  namespaces
  * es. `@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>.`
* Gli IRI sono sempre racchiusi tra `<' e '>`
* Ogni tripla termina con il punto `.`
    * Se ci sono tante triple con lo stesso soggetto oppure lo stesso soggetto e
      predicato, è possibile riportarli una volta sola e dividere le varie
      triple con il `;`
      es. `Spiderman friendOf Superman; Batman.`
* Se più triple hanno come stesso soggetto un blank node, allora si possono
  raggruppare (separate da `;`) con delle parentesi quadre
    * es. `[ :predicate1 :object; :predicate2 value ]`
    * es. `[] foaf:knows [ foaf:name "Bob" ]` $\equiv$ *"Qualcuno conosce
      una persona di nome Bob"*
* Tutti i tipi di dati sono implicitamente di tipo Stringa, però si possono
  specificare esplicitamente dopo il delimitatore `^^`
    * es. `schema:birthDate "1990-07-04"^^xsd:date`
* Esiste un sottoinsieme di Turtle chiamato **N-Triples**
    * È verboso e meno leggibile perché non ci sono le abbreviazioni che
      provvede di solito Turtle
    * Migliore per il trasferimento di dataset tra applicazioni
    * **N.B**: N-Quads è una sua estensione che aggiunge alla tripla un quarto
      elemento, il graph IRI (*che cos'è una quadrupla? una tripla +
      un'indicazione del grafo di appartenenza*)
* Ogni formato offre i suoi trade off:
    * RDF/XML: migliore interoperabilità con strumenti per XML
    * Turtle: leggibilità e compatibilità con SPARQL
    * N-triples: portabilità dei dati
    * Json LD: comunicazione client server via API

# RDF Schema

* RDF permette di creare un grafo per descrivere le risorse ma non si può dire
  più nulla su di esso, cioè non è possibile dare nessuna informazione sulle
  entità descritte dal vocabolario
* Con RDF possiamo definire classi, proprietà e gerarchie di classi e
  proprietà
* RDFs invece permette di definire:
    * Se una risorsa è una **classe**
    * Se una risorsa è una **proprietà**
    * Se una risorsa è una un'**istanza** di una classe
    * Se una proprietà è una **sottoproprietà** di una proprietà
    * Il **dominio** di una proprietà è una classe
    * Il **range** di una proprietà è una classe
* I namespace convenzionali sono di solito `rdf` per RDF e `rdfs` per RDF Schema
* **Attenzione**: Il predicato `type` è predefinito di RDF e non RDFs, per cui
  possiamo associare un tipo ad una risorsa anche già in RDF
    * es. `animals:Marty rdf:type animals:Zebra` 
    * `a` corrisponde a `rdf:type` 
    * es. `animals:Marty a animals:Zebra`
* Nonostante RDF e RDFs abbiano in modo combinato la potenza espressiva per
  descrivere risorse, hanno alcune limitazioni dal punto di vista del
  ragionamento automatico:
    * Non si può esprimere che due classi sono *disgiunte*
    * Non si può dire che una relazione è *transitiva*
    * Non si può dire che esistono individui
        * Possiamo dire solo che esistono risorse, cioè IRI creati
          **esternamente** al linguaggio
* RDF e RDFS insieme permettono di fare una qualche forma di ragionamento
  automatico (tabella con regole di inferenza specifiche su slides)

# Vocabolari RDF

* I vocabolari RDF sono un insieme di definizioni di classi e proprietà
* Successivamente, uno o più vocabolari vengono utilizzati per descrivere delle
  risorse
    * La descrizione di queste risorse è il *Knowledge Graph*
    * La descrizione di classi e proprietà è il *Vocabolario RDF*
* Precedentemente abbiamo citato come lo spirito di questi vocabolari RDF sia
  l'interoperabilità e il riutilizzo di altri vocabolari
* Alcuni dei vocabolari di utilizzo più comune sono:
    * **FOAF**: vocabolario per descrivere *reti sociali*
    * **Dublin Core**: vocabolario di elementi (*titolo, autore, ecc.*) per
      descrivere risorse in termini *editoriali*
    * **Schema.org**: vocabolario nato su iniziativa di un consorzio di
      industrie per descrivere gli argomenti delle pagine web secondo uno schema
      semantico
    * **SKOS**: W3C reccomendation dal 2009, permette di descrivere e allineare
      terminologie diverse

## Dublin Core

* Vocabolario che nasce per descrivere risorse nel web dall'ambito
  archivistico/bibliotecario
    * Con l'avvento del WWW, gli archivisti/bibliotecari si sono accorti che
      tantissimi dati di tipo multimediale venivano caricati provocando così la
      cosiddetta *data deluge* (alluvione di dati)
    * Questa crescita portò ad una grandissima difficoltà nell'indicizzazione
      di queste risorse
    * Ci fu quindi la necessità di creare un vocabolario standardizzato che
      permettesse di associare a questi dati multimediali dei metadati per la
      loro descrizione 
* Dublin Core fornisce un set di questi 15 elementi descrittivi generici:
    * Creator
    * Contibutor
    * Publisher
    * Title
    * Date
    * Language
    * Format
    * Subject
    * Description
    * Identifier
    * Relation
    * Source
    * Type
    * Coverage
    * Rights

> Dublin Core è quindi uno *schema di metadati* per annotare risorse testuali e
> multimediali, con lo scopo esplicito di facilitare il reperimento di risorse

* DC è in grado di descrivere un qualsiasi tipo di risorsa, cioè qualsiasi
  cosa che possa avere un'identità
    * Le risorse possono essere suddivide in diverse tipologie di classi:
        * Collezione
        * Dataset
        * Evento
        * Immagine
        * Risorsa interattiva
        * Servizio
        * Software
        * Suono
        * Testo
        * Oggetto fisico
* Lo schema di Dublin Core fu portato in RDF principalmente per poter effettuare
  ragionamento automatico
* Oltre che a diversi metadati, sono presenti anche dei termini in questo
  vocabolario quali:
  * **Label**: un'etichetta human-readable associata ad un termine
  * **Refines**: proprietà della quale il termine descritto è sotto-proprietà 
  * **Broader Than**: classe della quale il termine descritto è super-classe
  * **Has Range**: classe della quale il valore descritto del termine è istanza
  * (altre non descritte)
* I 15 elementi descrittivi, difatti, sono descritti utilizzando i termini di
  questo vocabolario

## Europeana

* È un archivio europeo dei beni culturali
* Metaportale che permette di avere accesso alle opere di diversi musei digitali
  di tutta europa
* Tutte le opere sono descritte in termini dei descrittori di Dublin Core
* Essenzialmente funge da aggregatore di tutti i vari musei che voglio
  condividere le loro opere
    * La condivisione si basa su un protocollo OAI-PMH (*Open Archives
      Initiative Protocol for Metadata harvesting*)
    * Secondo il protocollo, i vari musei espongono i metadati strutturati
      attraverso il protocollo
    * Europeana poi fa richieste per fare *harvesting* dei dati attraverso degli
      endpoint web specifici

## Schema.org

* Insieme di vocabolari con il fine di rappresentare schemi per rappresentare
  dati strutturati quali pagine web, email e altro
* Il vocabolario è suddiviso in diversi schemi (o types) organizzati in una
  tassonomia

## SKOS

* L'utilizzo di vocabolari di diverse provenienze, tipico dei Linked Data,
  annulla le relazioni tra i concetti proprio delle ontologie e si apre alle
  differenze
* SKOS (*Simple Knowledge Organization System*) è una raccomandazione del W3C
  per la creazione di schemi (vocabolari) di vario tipo: lessici, thesauri,
  ecc..
* Lo scopo è quello di facilitare e **uniformare** la pubblicazione dei
  vocabolari RDF come linked data
* Centrato sulla nozione di *"concetto"* e le sue relazioni con altri concetti
* Con SKOS è possibile:
    * Identificare concetti tramite URIs
    * Etichettare concetti con stringhe di linguaggio naturale
    * Assegnare annotazioni ai concetti
    * Documentare concetti con diverse tipologie di note
    * Connettere e organizzare concetti con gerarchie informali (informali
      perché ri-definiscono le solite relaizoni di sottoclasse che mette a
      disposizione RDF)
    * Mappare i concetti con altri concetti di altri schemi
* Ogni concetto in SKOS viene identificato con un URI
    * Ai concetti sono associate *etichette lessicali*:
        * `prefLabel`: etichetta preferenziale
            * es. `skos:prefLabel "animal"`
        * `altLabel`: etichetta alternativa
            * es. `skos:prefLabel "animaux"@fr; skos:altLabl "crèatures"@fr`
    * I concetti tra di loro possono essere relazionati tramite relazioni:
        * `narrower/broader`: relazione più specifica/generale
        * `related`: relazione generica di *relatedness* semantica
* SKOS mette a disposizione tutto un sistema ti etichette lessicali per
  associare ai concetti la loro **documentazione** quali `example` e
  `definition`, in modo da renderlo coprensibile alle persone
* Uno schema di concetti è una risorsa strutturata, ad esempio un thesauro, che
  in SKOS è rappresentato come una classe `ConceptScheme`
    * Tramite la relazione `inScheme` si indica l'appartenenza di un concetto
      allo schema 
* Nel seguente esempio si definisce un Thesauro definendolo come `ConceptScheme`
  e poi si aggiunge un concetto (`Concept`) ad esso

```
ex:animalThesaurus rdf:tyype skos:ConceptScheme;
    dc:title "Simple animal thesaurus";
    dc:creator ex:antoineIsaac.

ex:mammals rdf:type skos:Concept;
    skos:inScheme ex:animalThesaurus.
```

* Il predicato `broadMatch` serve a esprimere che due concetti (che possono
  stare anche in vocabolari diversi), sono uguali tra di loro
* Questo predicato non ha una semantica formale che permette il ragionamento
  automatico, ma permette comunque di esprimere questa relazione di
  corrispondenza
* COAR (*Confederation of Open Access Repositories*) è un vocabolario standard
  che contiene le definizioni dei vari tipi che utilizza SKOS
* Un'altra risorsa degna di nota è DCAT, che permette di descrivere datasets e
  servizi di dati in un catalogo utilizzando un modello standard e un
  vocabolario standard che facilita il consumo e l'aggregazione di metadati da
  diversi cataloghi, con lo scopo di aumentare la scopribilità dei
  dataset/servizi.
