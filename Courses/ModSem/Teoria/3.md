\newpage

# Ontologie Computazionali

* Un'ontologia è una rappresentazione astratta di concetti e di relazioni tra
  loro
* Le ontologie formali fissano un particolare formalismo di rappresentazione,
  con la finalità di condividere una concettualizzazione comune tra individui,
  organizzazioni e macchine

> *Definizione (Ontologia)*: Un artefatto ingegneristico, costituito da uno
> specifico **vocabolario** utilizzato per descrivere una certa realtà, più un
> insieme di assunzioni esplicite riguardo all'utilizzo inteso del vocabolario
> stesso.

* Le ontologie formali si basano su linguaggi formali per descrivere in maniera
  esplicita:
    * Le proprietà delle classi;
    * Le proprietà delle relazioni tra classi.
* Inoltre, i linguaggi permettono di fare ragionamento automatico (inferenze)
* Una possibile classificazione delle ontologie fa riferimento al loro livello
  di specificità:
    * **Ontologie Top-Level**: concetti fondazionali;
    * **Ontologie Mid-Level**: concetti generali ma non fondazionali, si basano
      su definizioni di ontologie top-level;
    * **Ontologie di Dominio**: rappresentano concetti e relazioni proprie di un
      dominio specifico.

## Ontologie Fondazionali
* Al giorno d'oggi ci sono diverse risorse ontologiche di tipo fondazionale, di
  seguito se ne vedono alcune.

### CYC
* L' ontologia fondazionale **CYC** (OpenCYC) è una base di conoscenza composta
  da: 
    * Termini, che compongono il vocabolario
    * Asserzioni che mettono in relazione questi termini. Le asserzioni a loro
      volta includono:
        * Asserzioni semplici
        * Regole (di ragionamento)
* La KB di CYC è suddivisa in migliaia di *microteorie*, ciascuna delle quali
  è costituita da un insieme di asserzioni che condividono le stesse assunzioni
    * Ogni microteoria si focalizza su un particolare dominio di conoscenza
    * Questo sistema di divisione permette di poter fare asserzioni
      apparentemente contraddittorie
* Il motore inferenziale di CYC è in grado di effettuare deduzione logica e di
  utilizzare anche i meccanismi di inferenza tipici dell'IA

### SuMO
* Un'altra ontologia top-level di particolare rilevanza è SuMO (*Suggested
  Upper Merged Ontology*)
* Non è scritta in OWL ma in un linguaggio di rappresentazione intermedia
  chiamato KIF. Esso contiene costrutti per esprimere:
  * **Termini**;
  * **Connettivi** (OR, AND);
  * **Quantificatori** e **implicazioni**.
* SuMO contiene:
    * Una gerarchia di classi (per ogni classe, SuMO ne descrive le
      caratteristiche attraverso un insieme di assiomi);
    * Un insieme di relazioni.
* SuMO introduce anche la possibilità di descrivere le relazioni stesse. Ad
  esempio è possibile dire che una proprietà è una relazione Asimmetrica e
  Transitiva

### YagoSuMO
* È l'integrazione tra Wikipedia, Wordnet (YAGO) e SuMO
* Contiene un corpus enorme di conoscenza formalizzata per fare inferenze e
  processing automatico della conoscenza;
* Grazie al mapping con Wordnet, permette di utilizzare il linguaggio naturale
  come mezzo d'interazione con la risorsa ontologica;
* Una versione più recente di YAGO è YAGO2, per cui integra anche altre
  risorse quali GeoNames.
    * L'accuratezza di YAGO è stata manualmente valutata.

### WordNet
* Risorsa ontologica di tipo linguistico (database lessicale)
* Suddivide le parole in *synsets*, cioè insiemi di parole che condividono lo
  stesso significato

### DbPedia
* È una versione semantica di Wikipedia che è stata costruita per mezzo di un
  processo di estrazione automatica.

## Linguaggi per descrivere ontologie

* I linguaggi per descrivere le ontologie sono il mezzo tramite il quale si va a
  formalizzare la conoscenza. Essi devono fornire costrutti per descrivere:
  * Classi e relazioni tra esse;
  * Disgiunzioni tra classi;
    * es. *Un vino non può essere sia bianco che rosso*.
  * Scomposizione esaustiva (e partizione).
    * es. *Canadesi, Statunitensi e Canadesi sono la scomposizione esaustiva di
      nordamericani*.
* I linguaggi che sono stati sviluppati che sono alla base del progetto web
  semantico sono basati sulle logiche descrittive
    * Queste logiche distinguono le definizioni dei concetti (**T-Box**), dalle
      asserzioni fatte sugli individui utilizzando quei concetti (**A-Box**);
    * In generale, le asserzioni che vengono fatte sulle classi e le proprietà
      fanno parte della T-Box, mentre tutte le altre asserzioni che utilizzano
      tali classi e proprietà fanno parte dell'A-Box;
    * Un'altra cosa importante sono i **ruoli**, che sono l'equivalente delle
      relazioni tra classi, per cui permettono di mettere in relazione diverse
      classi tra loro;
    * Grazie all'espressività delle logiche descrittive è possibile fare: 
        * **Instance checking**: verificare se un individuo appartiene ad una
          classe
        * **Relation checking**: verificare se vale una certa relazione tra
          classi
        * **Subsumption**: verificare se una classe è sottoinsieme di un'altra
          classe
        * **Concept consistency**: verificare che le definizioni e le loro
          conseguenze non siano contradditorie

## OWL2

* L'*Ontology Web Language* (OWL) è un linguaggio atto a creare ontologie per il
  web semantico con un significato definito formalmente;
* Tramite questo linguaggio è possibile definire:
  * Classi;
  * Proprietà;
  * Individui;
  * Letterali.
* Le ontologie scritte in questo linguaggio possono essere utilizzate in
  associazione con i documenti RDF;
  * Possono essere esse stesse codificate come documenti RDF.
* Uno degli aspetti fondamentali è che OWL si basa su logiche computazionali
  per cui permette di far ragionamento automatico utilizzando specifici software
  detti *reasoners*;
  * Questi software sono in grado di esplicitare la conoscenza implicita (fare
    inferenze) e di verificare la consistenza della base di conoscenza.
* Un aspetto non del tutto immediato di OWL è che non è possibile descrivere
  in maniera **prescrittiva** la struttura di un documento;
  * Ciò significa che non c'è modo di specificare che una determinata
    informazione deve essere **necessariamente** presente.
* Così come nelle logiche descrittive, anche OWL differenzia tra due tipologie
  di conoscenza:
  * **T-Box**: parte dell'ontologia che consiste nella *terminologia* che
    costituisce la conoscenza generale del dominio dato;
  * **A-Box**: asserzioni che descrivono entità concrete o specifiche del
    dominio dato.
* Più nel dettaglio, gli elementi di un'ontologia OWL sono:
    * **Entità**: elementi che si riferiscono al mondo reale. Possono essere:
        * **Individui**: specifiche istanze di classi;
        * **Classi**: rappresentano classi di individui che condividono le
          stesse caratteristiche;
        * **Proprietà**: rappresentano relazioni, sono suddivise in:
            * **Object properties**: relazioni da individuo a individuo;
            * **Datatype properties**: relazioni tra dato e individuo;
            * **Annotation properties**: relazioni che contengono commenti e
              descrizioni di qualsiasi entità.
    * **Assiomi**: asserzioni generali che possono essere:
        * **Class Axioms**:
            * **SubClassOf**: relazione di sottoclasse tra classi;
            * **EquivalentClasses**: relazione di equivalenza tra classi;
            * **DisjiontClasses**: relazione di disgiunzione;
            * **DisjointUnion**: relazione di unione disgiunta (due classi sono
              l'unione digiunta dell'altra se sono entrambe partizioni di una
              classe comune di cui sono entrambe sottoclassi).
        * **Dichiarazioni**;
        * **Asserzioni**;
        * **Assiomi su data properties**;
        * **Assiomi su object properties**;
        * (*Altre su documento OWL*).
    * **Espressioni**: combinazioni di entità che vanno a formare entità più
      complesse.
        * es. Una persona bella è un'entità persona ma che ha la *proprietà*
          di essere bella.

* In OWL le class e property expressions sono utilizzate per costruire
  delle **Class Expressions**, anche dette *descrizioni* (o *concetti complessi*
  seguendo la terminologia delle logiche descrittive)
    * Rappresentano un insieme di individui specificando formalmente le
      **condizioni** sulle proprietà degli individui
    * Una classe stessa è la forma più semplice di class expression
    * Per definire delle class expressions OWL mette a disposizione diversi
      operatori:
      * Connettivi booleani (`and, or`)
      * Quantificatori (`exists, forall`)
      * Restrizioni numeriche (`x < 100`)
      * Enumerazioni esplicite (`RegioniItaliane({Liguria, Piemonte, ..})`)

* Una classe si definisce dichiarandola come appartenente al tipo `owl:Class`
* Così come nelle reti semantiche, anche in OWL dichiariamo gerarchie di classi
  in un ordinamento tassonomico
    * Per dire che una classe è sottoclasse di un altra si utilizza sempre rdfs:
      `rdfs:subClassOf`
* Per esprimere l'equivalenza tra due classi `owl:equivalentClass`
* È possibile definire anche proprietà così come si fa con le classi, quindi
  dichiarando la proprietà come appartentente al tipo `owl:property`
* Anche le proprietà possono essere relazionate attraverso relazioni di
  sottoproprietà mediante il predicato `rdfs:subPropertyOf`
    * Se una proprietà vale per degli individui, vale anche quella più
      generale
* Altri predicati interessanti sono il `owl:sameAs` e `owl:differentFrom`
    * Permettono di specificare che due individui sono gli stessi oppure sono
      differenti
    * Particolarmente utili quando si fa allineamento tra diverse basi di
      conoscenza
* Le data properties collegano un dominio (tipi di dati) ad una classe
    * Si definiscono come si defniscono classi e proprietà utilizzando come
      tipo `owl:dataProperty`
* OWL mette a disposizione il meccanismo delle **restrizioni** per definire
  nuove classi a partire da quelle esistenti. Ci sono due tipi di restrizioni
  principali:
  * Restrizioni su classi (mediante operatori insiemistici)
  * Restrizioni su proprietà (mediante operatori esistenziali, universali e
    sulla cardinalità)

> Le classi che sono definite come **equivalenti** `equivalentTo` ad un certo
> insieme di restrizioni sono dette **classi definite**. Le restrizioni
> individuano le condizioni *necessarie e sufficienti* per l'appartenenza alla
> classe. D'altra parte, le classi definite come **sottoclassi** `subclassOf` ad
> un certo insieme di restrizioni sono dette **classi primitive**. In questo
> caso, le restrizioni sono condizioni solamente *necessarie* ma *non
> sufficienti*

* Le classi primitive non permettono al reasoner di collocare gli individui in
  modo automatico nelle classi, ma permettono solamente al reasoner di rilevare
  le inconsistenze con le asserzioni sugli individui

* OWL permette anche di descrivere delle caratteristiche delle proprietà quali:
    * Simmetriche;
    * Funzionali;
    * Inverse;
    * Riflessive;
    * Transitive.

## Ragionamento Automatico

* Le ontologie computazionali permettono ai reasoners di fare ragionamento
  automatico
  * Questi reasoner possono esplicitare la conoscenza implicita facendo
    inferenze, oppure possono validare la correttezza della base di conoscenza
* Il ragionamento avviene su più livelli:
    * **Classi**;
        * Il reasoner è in grado di inferire relazioni di sussunzione tra le classi
          a partire dalla descrizione delle stesse;
        * La gerarchia di classi inferita può anche essere diversa da quella
          dichiarata.
    * **Inserimento di individui**;
        * Il reasoner assegna un particolare individuo ad una classe
          automaticamente sulla base delle sue proprietà/caratteristiche;
        * es. Se ho un individuo che è in relazione con un altro, il reasoner
          può capire a che classe appartiene guardando il **dominio** della
          relazione;
        * Eventualmente, è possibile che un individuo venga riassociato ad
          un'altra classe;
        * Il reasoner è anche in grado di rilevare se un individuo appartiene a
          una o più classi disgiunte, cioè se c'è un'inconsistenza sotto
          questo punto di vista.
    * **Classificazione Automatica**;
        * È un caso specifico dell'inserimento, essenzialmente è in grado di
          capire se un individuo che fa parte di una classe più generale fa in
          realtà parte di una sottoclasse più specifica.
        * es. Da `Persona` a `Studente`
    * **Restrizioni su DataProperties**;
        * Verifica che le restrizioni su data properties (Domain e Range) siano
          consistenti.
    * **Property Chain**.
        * es. Se A è coinquilino di B e B risiede in un certo luogo, allora
          anche A risiede nello stesso luogo.

> I reasoners OWL fanno un'assunzione di **mondo aperto**: il fatto che
> un'informazione non sia rappresentata nel sistema non determina che essa sia
> assunta falsa.

* Ad esempio, spesso è necessario asserire esplicitamente che due individui
  siano differenti poiché il reasoner può supporre che siano entrambi lo
  stesso individuo
* **Quantificazione Universale**: Se si hanno due classi che sono
  rispettivamente definite su una quantificazione universale su due classi
  dichiarate disgiunte, e si asserisce che un individuo appartiene ad entrambe
  le classi, il reasoner rileva un'inconsistenza
    * es. Siano `GenitoriFigliMaggiorenni` e `GenitoriFigliMinorenni`
      rispettivamente le due classi definite con quantificatore universale
      `only` su `Maggiorenni` e `Minorenni`
    * Siccome `Maggiorenni` e `Minorenni` sono disgiunte, allora se si assegna
      ad un individuo sia la classe `GenitoriFigliMinorenni` che la classe
      `GenitoriFigliMaggiorenni`, il reasoner rileva un'inconsistenza
* La quantificazione universale `only` significa che **tutti** gli individui
  devono essere vincolati in quel modo, ma non implica che ce ne debba essere
  almeno uno
    * Per ottenere ciò si combina con l'assioma `some`
    * es. `SoloPittore equivalentTo [crea some Dipinto and crea only Dipinto]`
      che un artista che è solo pittore è un artista che ha creato solo
      dipinti (avendone prodotto almeno uno)

## Ontology Engineering

* L'ambito che si occupa del design delle ontologie e del loro mantenimento è
  chiamato **Ontology Engineering**;
* L'idea è quella di fornire principi di modellazione che siano standard e
  comuni a tutte le ontologie in modo da facilitarne l'interoperabilità;
* Alcune di queste metodologie tra le più affermate sono *OntoClean* e *Neon*.

### OntoClean

* È una metodologia che si basa su nozioni ontologiche molto generali ispirate
  dalla filosofia (es. essenza, identità, unità). Tali nozioni sono utilizzate
  per caratterizzare aspetti rilevanti del **significato inteso** delle
  proprietà, classi e relazioni che compongono un'ontologia
    * Gli aspetti sono rappresentati da metaproprietà che determinano dei
      vincoli sulla struttura tassonomica dell'ontologia

> Ontoclean è un'analisi delle classi dell'ontologia nei termini delle loro
> metaproprietà che porta alla verifica e all'eventuale revisione della
> **struttura tassonomica** dell'ontologia

* Le metaproprietà menzionate sono 4, ognuna identificata da una lettera:
    * `(I)` - Identità: ciò che è identificabile
    * `(U)` - Unità: ciò che è unitario
    * `(R)` - Rigidità: ciò che non è soggetto a cambiamenti
    * `(D)` - Dipendenza
* Una classe è definita come *"definizione che determina l'appartenenza di
  individui alla classe"*
* La metodologia consiste nei seguenti passaggi:
    1. Ogni classe viene annotata con le meta-proprietà
        * `+P` se la classe possiede la proprietà `P`
        * `-P` se la classe non possiede la proprietà `P`
        * `~P` se la classe possiede l'anti-proprietà di `P`
    2. Si analizzano le meta-proprietà delle classi, da cui emergeranno
       determinati vincoli di sussunzione (struttura tassonomica) in base alle
       sue metaproprietà
        * es. Una classe *anti-rigida* non può sussumere una classe *rigida*
    3. I vincoli si utilizzano per ristrutturare e verificare la gerarchia delle
       classi

* **Phased Sortals**: entità che rimangono le stesse pur modificando in parte i
  propri criteri di identità (es. bruco che diventa farfalla). Vengono
  individuati associandone le proprietà di:
    * Indipendenza (-D)
    * Anti Rigidità (~R)
    * Hanno un criterio di identità (+I)

* Le metaproprietà possono essere ereditate dalle sottoclassi:
    * Identità: ereditata dalle sottoclassi
    * Unità: ereditata dalle sottoclassi, ma non vale per (-U)
    * Rigidità: non viene ereditata dalle sottoclassi, ma l'antirigidità (~R)
      si
* Le proprietà che vengono sussunte non possono essere anti proprietà oppure
  non possono non possederla, in quel caso si otterrebbe una contraddizione che
  deve essere risolta nel processo di revisione
* Il processo di revisione può anche portare all'introduzione di nuove classi
  in modo da risolvere le contraddizioni

### NeOn
* Metodologia orientata agli aspetti collaborativi dello sviluppo e mantenimento
  di un network di ontologie
* Prevede un insieme di 9 scenari possibili a cui sono associate specifiche
  attività e documenti 
    * Scenario 1: Dalle specifiche all'implementazione
    * Scenario 2: Riutilizzo e re-ingenierizzazione delle risorse
      non-ontologiche
    * Scenario 3: Riutilizzo delle risorse ontologiche
    * Scenario 4: Riutilizzo e re-ingenierizzazione delle risorse ontologiche
    * Scenario 5: Riutilizzo e fusione delle risorse ontologiche
    * Scenario 6: Riutilizzo, fusione e re-ingenierizzazione delle risorse
      ontologiche
    * Scenario 7: Riutilizzo di ontology design patterns (ODPs)
    * Scenario 8: Ristrutturazione di risorse ontologiche
    * Scenario 9: Localizzazione di risorse ontologiche
* Un'altro aspetto importante di NeOn è il focus sul ciclo di vita delle
  ontologie. Secondo NeOn ogni ontologia ha un ciclo di vita composto dalle
  seguenti fasi:
  * Fase di inizio
  * Fase di design
  * Fase di implementazione
  * Fase di mantenimento
* È poi possibile ottenere un'ulteriore iterazione dell'ontologia eventualmente
  della fase di design, implementazione e mantenimento, in modo da ottenere un
  raffinamento ulteriore dell'ontologia

### Ontology Design Patterns (ODP)
* Sono una sorta di mattoncini per la creazione di ontologie secondo schemi
  (pattern) ricorrenti condivisi
* Sono divisi in in diverse categorie:
    * Strutturali
    * Corrispondenza
    * Contenuto
    * Presentazione 
    * Sintattico-Lessicale
* Ad esempio, un pattern molto famoso è quello che rappresenta il concetto di
  lista
* Gli ODP sono ispirati direttamente ad un'ontologia fondazionale chiamata
  DOLCE 

### DOLCE
* È un'ontologia orientata alla cognizione e al linguaggio
* La distinzione chiave tra gli elementi in DOLCE è tra *enduranti*, cioè le
  entità temporali e i processi che nel linguaggio naturale sono descritti
  tramite verbi (correre, mangiare, ecc..) e *perduranti*, cioè quelle entità
  che esistono al di fuori dal tempo, cioè gli oggetti ed entità che
  partecipano ai processi

> *"Gli enduranti sono interamente presenti in ogni istante in cui sono
> presenti. I perduranti semplicemente si estendono nel tempo accumulando
> diverse parti temporali in modo che ad ogni istante in cui sono presenti, sono
> solamente parzialmente presenti."*

* Es. Una persona scala una montagna
    * La persona è sempre la stessa durante l'atto, per cui è un endurante
    * Il processo di scalare la montagna è un perdurante invece, poiché
      all'inizio la persona ne avrà scalata un quarto, poi metà e poi tutta,
      per cui è un processo che accumula parti

* Il concetto di partecipazione ad un evento da questo punto di vista è
  catturato da un ODP: il *Content Design Pattern*.
    * `ParticipanRole` collega un `Evento` e un `Oggetto` che partecipa
      all'evento (per esempio un agente) con un `Ruolo` con cui avviene la
      partecipazione;
    * Essenzialmente collega un oggetto che partecipa ad un evento attraverso il
      ruolo che prende nella partecipazione dello stesso;
    * Questo pattern di partecipazione tramite un ruolo ad un evento ha diverse
      formulazioni differenti poiché compare in molte situazioni.

### Provenance Ontology
* Risorsa ontologica di rilevanza attuale concepita per rappresentare la
  provenienza delle entità 
* Descrive l'origine delle entità intesa soprattutto come processi che hanno
  *determinato la creazione* di quelle entità
* I metadati delle entità e la descrizione degli agenti è affidata ad altre
  ontologie come FOAF (agenti) e Dublin Core (entità)
* Composta da 3 classi principali: `Entity`, `Agent` e `Activity`
    * `Entity` - `wasDerivedFrom` -> `Entity`
    * `Entity` - `wasGeneratedBy` -> `Activity`
    * `Activity` - `used` -> `Entity`
    * `Activity` - `wasAssociatedWith` -> `Agent`
    * `Entity` - `wasAttributedTo` -> `Agent`
* Un agente prende parte ad un'attività attraverso un ruolo in modo tale che
  all'agente possa essere assegnato un certo grado di responsabilità per
  l'attività a cui sta partecipando
    * Un agente può essere una persona, un software, un oggetto inanimato o
      qualsiasi altra entità a cui possa essere attribuita una responsabilità 
* Le attività definiscono come le entità vengono ad esistere e come i loro
  attributi cambino per diventare nuove entità
* Un ruolo è la descrizione della funzione o della parte che un entità ha
  svolto nell'attività
    * Il ruolo viene rappresentato come una qualified association, cioè si
      annota nella relazione di `wasAssociatedWith` tramite la relazione
      `hadRole` e un blank node che connette l'attività all'associazione e il
      ruolo
