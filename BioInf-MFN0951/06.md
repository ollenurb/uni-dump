# Alberi Filogenetici
* Fino agli anni '60, le relazioni evoluzionistiche tra specie erano determinate
  dalle caratteristiche anatomiche
* A causa di questa metodologia, le osservazioni erano spesso soggettive, per
  cui molte ricostruzioni evolutive si rivelarono errate
* Un esempio ecclatante fu proprio quello del *Panda Gigante*
    * Per la loro stazza assomigliano molto agli orsi, per cui sarebbero
      ragionevolmente associabili agli orsi
    * Essi hanno pero' anche features tipiche dei procioni
    * Si creo' cosi' un dilemma, che fu risolto solamente con l'avvento del
      sequenziamento del DNA
* L'utilizzo del DNA e' possibile capire come si sono differenziati i geni da
  una specie all'altra, ed e' inoltre possibile stimare il tempo che e'
  intercorso tra il passaggio da una specie ad un'altra
* Determinare alberi evolutivi per mezzo del sequenziamento genetico ha quindi
  un lato positivo: permette una valutazione *oggettiva* rispetto ad una
  valutazione *soggettiva*, impiegata maggiormanete dall'approccio piu'
  tradizionale
* Il problema di questo approccio e' che un determinato insieme di geni non e'
  spesso sufficiente a discriminare una specie da un'altra
* Ricostruire correttamente un albero evolutivo non e' un compito semplice
* Per fare un altro esempio, anche la ricostruzione dell'albero evolutivo
  dell'uomo ha diverse ipotesi
    * Secondo la prima, la specie umana si e' sviluppata completamente in
      Africa, per poi migrare successivamente nel resto del mondo, rimpiazzando
      le altre specie umanoidi che lo popolavano
    * Secondo la seconda, l'uomo deriva tra due popolazioni: quella africana e
      quella non africana. Addirittuare, alcune popolazioni nell'albero
      condividono gli stessi tratti per cui non e' possibile farle risalire ad
      un sottoinsieme specifico

## Alberi Evolutivi
* Un albero evolutivo e' un albero costruito dalle sequenze di DNA di diversi
  organismi in cui:
    * **Foglie**: specie esistenti
    * **Vertici Interni**: specie antenate
    * **Archi**: passo evolutivo
    * **Radice**: specie antenata piu' antica di tutte le specie rappresentate
      nell'albero
* Siccome in alcune specie non e' possibile determinare l'antenato originale, ci
  sono due varianti di albero evolutivo: con radice e senza radice
* Gli alberi possono anche avere archi pesati, in modo da riflettere il numero
  di mutazioni tra una specie e l'altra, oppure il tempo che e' intercorso tra
  il salto evolutivo
* Con $d_{i,j}(T)$ si indica la distanza del percorso tra le foglie $i$ e $j$
  nell'albero evolutivo $T$
* Date $n$ specie, la **matrice di distanza** $n \times n$ e' la matrice
  $D_{i,j}$ definita come l'edit distance tra un gene della specie $i$ e della
  specie $j$, dove il gene di interesse e' sequenzializzato per TUTTE le $n$
  specie
* Goal dell'algoritmo: Ricostruire l'albero che riproduce esattamente le
  distanze sui cammini, cioe' $D_{i,j} = d_{i,j}(T)$
* Osserviamo in un albero a 3 foglie, ogni distanza $D$ e' pari alla somma delle
  distanze dei percorsi, per cui possiamo costruire l'albero a partire da un
  sistema a 3 incognite
* Per alberi con il numero di foglie $n > 3$, il sistema ha $2n-3$ variabili e
  $\frac{n(n-1)}{2}$ equazioni, per cui non sempre e' risolvibile
* **Matrice Additiva**: Una matrice $D$ e' detta *additiva* se esiste un'albero
  $T$ tale per cui $d_{i,j}(T) = D_{i,j}$ (se e' consistente con un albero $T$)
* Vogliamo che l'algoritmo per la costruizione dell'albero filogenetico abbia le
  seguenti caratteristiche:
    * **Obiettivo**: Ricostruire un albero evolutivo a partire da una matrice di
      distanza
    * **Input**: Matrice $D (n \times n)$ di distanza
    * **Output**: Albero pesato $T$ con $n$ foglie consistente con $D$
* In caso la matrice di distanza sia additiva il problema e' di semplice
  soluzione
* **Idea**: Individuare due foglie vicine e comprimerle sul proprio nodo
  genitore:
    * Selezionate due foglie $i$ e $j$ con genitore $k$ si possono comprimere
      nel modo seguente:
        1. Rimuovi le righe e colonne di $i$ e $j$
        2. Aggiungi una nuova riga e colonna corrispondente a $k$, dove la distanza
           da $k$ ad ogni altra foglia $m$ e' calcolabile con la seguente formula
           $$
           D_{k,m} - \frac{D_{i,m} + D_{j,m} - D_{i,j}}{2}
           $$

* Un criterio possibile con cui sceliere i nodi vicino e' quello di selezionare
  semplicemente quelle piu' vicine, anche se non sempre e' un criterio giusto

## Filogenetica Additiva
* Vediamo in questa sezione come e' possibile costruire una matrice additiva
* **Tripla Degenerata**: Insieme di 3 vertici $i, j, k$ tale per cui la somma
  delle distanze tra $i,j$ e $i,k$ e' uguale alla distanza tra $i,k$ ($D_{i,j}
  + D_{j,k} = D_{i,k}$)
* L'interpretazione e' che $j$ e' perfettamente nel mezzo tra $i$ e $k$, oppure
  e' "agganciato" al cammino con costo $0$
* E' possibile creare delle triple degenerate andando ad "accorciare" tutti gli
  archi all'interno dell'albero
* Se non esistono triple degenerative all'interno della matrice, tutti gli
  archi vengono decrementati di una certa quantita' $\delta$, per cui tutte
  le distanze tra le coppie saranno decrementate di $2\delta$
* Il processo portera' eventualmente a "collassare" una delle foglie,
  formando una tripla degenerativa e riducendo la dimensione della matrice
  $D$
* Il punto di "ancoraggio" del nodo rimosso puo' essere ricostruito andando a
  salvare i $D_{ij}$ delle foglie collassate
* E' possibile sfruttare questo modo di procedere per ottenere l'albero
  filogenetico:
    * Si procede iterativamente a ridurre la matrice trovando via via tutte le
      triple degenerative fino a quando la matrice e' composta da soli 2 nodi.
    * Si ricompone l'albero applicando i passi inversi
* Il processo di ricostruzione dell'albero che sfrutta questa tecnica prende il
  nome di **filogenetica additiva**:

```
AdditivePhylogeny(D)
  if D is a 2 x 2 matrix
    T = tree of a single edfe of lengh D_{1,2}
    return T
  if D is non-degenerate
    delta = trimming parameter of matrix D
    for all 1 <= i != j <= n
      D_{i,j} = D_{i,j} - 2 * delta
  else
    delta = 0
  Find a triple i,j,k in D such that D_{i,j} + D_{i,k} = D_{i,k}
  x = D_{i,j}
  Remove j-th row and j-th column from D
  Add a new vertex v to T at distance x from i to k
  Add j back to T by creating an edge (v, j) of length 0
  for every leaf l in T:
    if distance from I to v in the tree != D_{i,j}
      output "matrix is not additive"
      return
  Extend all "hanging" edges by length delta
  return T
```



